// Prisma Schema for Awareness Network
// Database: PostgreSQL (Supabase)

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ============================================================================
// Core Tables (Existing - from Drizzle)
// ============================================================================

model User {
  id                   Int       @id @default(autoincrement())
  openId               String?   @unique @db.VarChar(64)
  name                 String?
  email                String?   @db.VarChar(320)
  password             String?   @db.VarChar(255)
  emailVerified        Boolean   @default(false) @map("email_verified")
  loginMethod          String?   @db.VarChar(64) @map("loginMethod")
  role                 UserRole  @default(consumer)
  userType             UserType? @map("user_type")
  onboardingCompleted  Boolean   @default(false) @map("onboarding_completed")
  bio                  String?
  avatar               String?
  createdAt            DateTime  @default(now())
  updatedAt            DateTime  @updatedAt
  lastSignedIn         DateTime? @map("lastSignedIn")

  // Wallet & Credits (for Phantom Auth and Hive Mind)
  walletAddress        String?   @unique @map("wallet_address") @db.VarChar(42)
  creditsBalance       Decimal   @default(0) @map("credits_balance") @db.Decimal(18, 4)
  totalMemories        Int       @default(0) @map("total_memories")
  totalResonances      Int       @default(0) @map("total_resonances")

  // Relations
  createdWorkflows      Workflow[]
  createdVectors        LatentVector[]
  transactions          Transaction[]
  accessPermissions     AccessPermission[]
  reviews               Review[]
  subscriptions         UserSubscription[]
  notifications         Notification[]
  apiKeys               ApiKey[]
  mcpTokens             McpToken[]
  memoryUsageAsConsumer MemoryUsageLog[] @relation("MemoryConsumer")
  memoryUsageAsProvider MemoryUsageLog[] @relation("MemoryProvider")
  verificationCodes     VerificationCode[]
  blogPosts             BlogPost[]
  agentWallet           AgentWallet?
  agentWalletTxs        AgentWalletTransaction[]

  // Ensure no duplicate emails (allows multiple NULLs for wallet-only users)
  @@unique([email], map: "unique_email_non_null")
  @@map("users")
}

enum UserRole {
  user
  admin
  creator
  consumer
}

enum UserType {
  creator
  consumer
  both
}

// ============================================================================
// NEW: Agent Collaboration Workflows
// ============================================================================

model Workflow {
  id                  String            @id @db.VarChar(64)
  task                String            @db.VarChar(500)
  description         String?
  status              WorkflowStatus    @default(pending)
  orchestration       Orchestration
  memorySharing       MemorySharing     @default(enabled) @map("memory_sharing")
  memoryTTL           Int               @default(86400) @map("memory_ttl") // seconds
  maxExecutionTime    Int               @default(600) @map("max_execution_time") // seconds
  recordOnChain       Boolean           @default(true) @map("record_on_chain")

  // Execution tracking
  sharedMemory        Json?             @map("shared_memory")
  startedAt           DateTime?         @map("started_at")
  completedAt         DateTime?         @map("completed_at")
  totalExecutionTime  Int?              @map("total_execution_time") // milliseconds

  // Relations
  createdBy           Int               @map("created_by")
  creator             User              @relation(fields: [createdBy], references: [id])
  steps               WorkflowStep[]
  interactions        OnChainInteraction[]

  createdAt           DateTime          @default(now()) @map("created_at")
  updatedAt           DateTime          @updatedAt @map("updated_at")

  @@index([createdBy])
  @@index([status])
  @@index([createdAt])
  @@map("workflows")
}

model WorkflowStep {
  id              Int             @id @default(autoincrement())
  workflowId      String          @map("workflow_id") @db.VarChar(64)
  stepIndex       Int             @map("step_index")

  // Agent information
  agentId         String          @map("agent_id") @db.VarChar(255)
  agentName       String?         @map("agent_name") @db.VarChar(255)

  // Execution status
  status          StepStatus      @default(pending)

  // Input/output
  input           Json?
  output          Json?
  error           String?

  // Memory coordination
  memoryKeys      Json?           @map("memory_keys") // Array of memory keys

  // Timing
  startedAt       DateTime?       @map("started_at")
  completedAt     DateTime?       @map("completed_at")
  executionTime   Int?            @map("execution_time") // milliseconds

  // Relations
  workflow        Workflow        @relation(fields: [workflowId], references: [id], onDelete: Cascade)

  createdAt       DateTime        @default(now()) @map("created_at")

  @@unique([workflowId, stepIndex])
  @@index([workflowId, stepIndex])
  @@map("workflow_steps")
}

model OnChainInteraction {
  id              Int             @id @default(autoincrement())

  // Workflow context (optional)
  workflowId      String?         @map("workflow_id") @db.VarChar(64)
  workflow        Workflow?       @relation(fields: [workflowId], references: [id], onDelete: SetNull)

  // Agent interaction
  fromAgentId     String          @map("from_agent_id") @db.VarChar(255)
  toAgentId       String          @map("to_agent_id") @db.VarChar(255)

  // Interaction result
  success         Boolean
  weight          Int             @default(50) // Reputation weight
  interactionType String          @default("collaboration") @map("interaction_type") @db.VarChar(50)

  // Blockchain proof
  txHash          String?         @map("tx_hash") @db.VarChar(66)
  blockNumber     Int?            @map("block_number")

  recordedAt      DateTime        @default(now()) @map("recorded_at")

  @@index([workflowId])
  @@index([fromAgentId])
  @@index([toAgentId])
  @@index([txHash])
  @@map("on_chain_interactions")
}

model CollaborationRecord {
  id               Int      @id @default(autoincrement())
  sessionId        String   @map("session_id") @db.VarChar(64)
  agentType        String   @map("agent_type") @db.VarChar(50)
  agentId          String   @map("agent_id") @db.VarChar(255)
  taskHash         String   @map("task_hash") @db.VarChar(66)
  qualityScore     Decimal  @map("quality_score") @db.Decimal(5, 2)
  timestamp        DateTime @db.Timestamp(6)
  contributionType String   @map("contribution_type") @db.VarChar(50)
  createdAt        DateTime @default(now()) @map("created_at")

  @@index([sessionId])
  @@index([agentId])
  @@index([taskHash])
  @@map("collaboration_records")
}

// ============================================================================
// NEW: W-Matrix Marketplace
// ============================================================================

model WMatrixCompatibility {
  id                  Int                 @id @default(autoincrement())
  wMatrixId           String              @map("w_matrix_id") @db.VarChar(64)
  sourceModel         String              @map("source_model") @db.VarChar(100)
  targetModel         String              @map("target_model") @db.VarChar(100)

  // Semantic versioning
  version             String              @db.VarChar(20)
  versionMajor        Int                 @map("version_major")
  versionMinor        Int                 @map("version_minor")
  versionPatch        Int                 @map("version_patch")

  // Quality metrics
  certification       CertificationLevel
  epsilon             Decimal             @db.Decimal(10, 6)
  cosineSimilarity    Decimal?            @map("cosine_similarity") @db.Decimal(10, 6)
  euclideanDistance   Decimal?            @map("euclidean_distance") @db.Decimal(18, 6)
  testSamples         Int?                @map("test_samples")

  // Availability
  available           Boolean             @default(true)

  // Storage
  downloadUrl         String?             @map("download_url") @db.VarChar(512)
  checksumSHA256      String?             @map("checksum_sha256") @db.VarChar(66)
  sizeBytes           Int?                @map("size_bytes")

  // Metadata
  createdBy           Int?                @map("created_by")
  createdAt           DateTime            @default(now()) @map("created_at")

  @@index([sourceModel, targetModel])
  @@index([certification])
  @@index([versionMajor, versionMinor, versionPatch])
  @@index([wMatrixId])
  @@map("w_matrix_compatibility")
}

model WMatrixListing {
  id                  Int                 @id @default(autoincrement())
  sourceModel         String              @map("source_model") @db.VarChar(100)
  targetModel         String              @map("target_model") @db.VarChar(100)
  title               String              @db.VarChar(255)
  description         String
  creatorId           Int                 @map("creator_id")

  // Dimensions
  sourceDimension     Int                 @map("source_dimension")
  targetDimension     Int                 @map("target_dimension")

  // Pricing
  price               Decimal             @db.Decimal(18, 2)

  // Version and quality
  version             String              @db.VarChar(20)
  standard            WMatrixStandard
  certification       CertificationLevel?
  qualityGrade        String?             @map("quality_grade") @db.VarChar(2)

  // Quality metrics
  epsilon             Decimal             @db.Decimal(10, 6)
  cosineSimilarity    Decimal?            @map("cosine_similarity") @db.Decimal(10, 6)
  euclideanDistance   Decimal?            @map("euclidean_distance") @db.Decimal(18, 6)
  testSamples         Int?                @map("test_samples")

  // Storage
  storageUrl          String              @map("storage_url") @db.VarChar(512)
  checksumSHA256      String?             @map("checksum_sha256") @db.VarChar(66)
  sizeBytes           Int?                @map("size_bytes")

  // Marketplace metadata
  tags                Json?
  status              ListingStatus       @default(active)
  downloads           Int                 @default(0)
  views               Int                 @default(0)
  avgRating           Decimal?            @map("avg_rating") @db.Decimal(3, 2)
  reviewCount         Int                 @default(0) @map("review_count")

  // Training metadata (optional)
  trainingDataSize    Int?                @map("training_data_size")
  trainingEpochs      Int?                @map("training_epochs")
  trainingLoss        Decimal?            @map("training_loss") @db.Decimal(10, 6)

  createdAt           DateTime            @default(now()) @map("created_at")
  updatedAt           DateTime            @updatedAt @map("updated_at")

  @@index([sourceModel, targetModel])
  @@index([creatorId])
  @@index([status])
  @@index([certification])
  @@map("w_matrix_listings")
}

model WMatrixIntegrity {
  listingId           String              @id @map("listing_id") @db.VarChar(64)
  expectedChecksum    String              @map("expected_checksum") @db.VarChar(66)
  actualChecksum      String?             @map("actual_checksum") @db.VarChar(66)
  sizeBytes           Int?                @map("size_bytes")
  valid               Boolean?
  lastVerifiedAt      DateTime?           @map("last_verified_at")
  verificationCount   Int                 @default(1) @map("verification_count")
  createdAt           DateTime            @default(now()) @map("created_at")

  @@map("w_matrix_integrity")
}

// ============================================================================
// Enums
// ============================================================================

enum WorkflowStatus {
  pending
  running
  completed
  failed
  cancelled
}

enum Orchestration {
  sequential
  parallel
}

enum MemorySharing {
  enabled
  disabled
}

enum StepStatus {
  pending
  running
  completed
  failed
}

enum CertificationLevel {
  bronze
  silver
  gold
  platinum
}

enum WMatrixStandard {
  standard_4096  @map("4096")
  standard_8192  @map("8192")
  standard_16384 @map("16384")
}

enum ListingStatus {
  active
  inactive
  suspended
}

// ============================================================================
// Core Business Tables
// ============================================================================

model LatentVector {
  id                  Int       @id @default(autoincrement())
  creatorId           Int       @map("creator_id")
  title               String    @db.VarChar(255)
  description         String
  category            String    @db.VarChar(100)
  vectorFileKey       String    @map("vector_file_key")
  vectorFileUrl       String    @map("vector_file_url")
  modelArchitecture   String?   @map("model_architecture") @db.VarChar(100)
  vectorDimension     Int?      @map("vector_dimension")
  performanceMetrics  String?   @map("performance_metrics")
  basePrice           Decimal   @map("base_price") @db.Decimal(10, 2)
  pricingModel        String    @default("per-call") @map("pricing_model") @db.VarChar(50)
  status              String    @default("draft") @db.VarChar(20)
  totalCalls          Int       @default(0) @map("total_calls")
  totalRevenue        Decimal   @default(0) @map("total_revenue") @db.Decimal(12, 2)
  averageRating       Decimal?  @default(0) @map("average_rating") @db.Decimal(3, 2)
  reviewCount         Int       @default(0) @map("review_count")
  freeTrialCalls      Int       @default(3) @map("free_trial_calls")
  createdAt           DateTime  @default(now()) @map("createdAt")
  updatedAt           DateTime  @default(now()) @updatedAt @map("updatedAt")

  // Hive Mind / SDK Memory fields
  vectorType          String?   @default("marketplace") @map("vector_type") @db.VarChar(50)
  memoryType          String?   @default("latent_vector") @map("memory_type") @db.VarChar(50)
  embeddingProvider   String?   @map("embedding_provider") @db.VarChar(50)
  embeddingModel      String?   @map("embedding_model") @db.VarChar(100)
  embeddingDimension  Int?      @map("embedding_dimension")
  embeddingData       String?   @map("embedding_data") @db.Text  // JSON array stored as text
  isPublic            Boolean   @default(false) @map("is_public")
  resonanceCount      Int       @default(0) @map("resonance_count")
  lastResonanceAt     DateTime? @map("last_resonance_at")

  // Relations
  creator             User              @relation(fields: [creatorId], references: [id])
  transactions        Transaction[]
  accessPermissions   AccessPermission[]
  reviews             Review[]
  apiCallLogs         ApiCallLog[]

  @@index([creatorId])
  @@index([category])
  @@index([status])
  @@index([isPublic])
  @@map("latent_vectors")
}

model Transaction {
  id                    Int       @id @default(autoincrement())
  buyerId               Int       @map("buyer_id")
  vectorId              Int       @map("vector_id")
  amount                Decimal   @db.Decimal(10, 2)
  platformFee           Decimal   @map("platform_fee") @db.Decimal(10, 2)
  creatorEarnings       Decimal   @map("creator_earnings") @db.Decimal(10, 2)
  stripePaymentIntentId String?   @map("stripe_payment_intent_id") @db.VarChar(255)
  status                String    @default("pending") @db.VarChar(20)
  transactionType       String    @default("one-time") @map("transaction_type") @db.VarChar(20)
  createdAt             DateTime  @default(now()) @map("createdAt")
  updatedAt             DateTime  @default(now()) @updatedAt @map("updatedAt")

  // Relations
  buyer                 User              @relation(fields: [buyerId], references: [id])
  vector                LatentVector      @relation(fields: [vectorId], references: [id])
  accessPermissions     AccessPermission[]

  @@index([buyerId])
  @@index([vectorId])
  @@index([status])
  @@map("transactions")
}

model AccessPermission {
  id              Int       @id @default(autoincrement())
  userId          Int       @map("user_id")
  vectorId        Int       @map("vector_id")
  transactionId   Int       @map("transaction_id")
  accessToken     String    @unique @map("access_token") @db.VarChar(255)
  expiresAt       DateTime? @map("expires_at")
  callsRemaining  Int?      @map("calls_remaining")
  isActive        Boolean   @default(true) @map("is_active")
  createdAt       DateTime  @default(now()) @map("createdAt")
  updatedAt       DateTime  @default(now()) @updatedAt @map("updatedAt")

  // Relations
  user            User          @relation(fields: [userId], references: [id])
  vector          LatentVector  @relation(fields: [vectorId], references: [id])
  transaction     Transaction   @relation(fields: [transactionId], references: [id])

  @@index([userId, vectorId])
  @@index([accessToken])
  @@map("access_permissions")
}

model Review {
  id                  Int       @id @default(autoincrement())
  vectorId            Int       @map("vector_id")
  userId              Int       @map("user_id")
  rating              Int
  comment             String?
  isVerifiedPurchase  Boolean   @default(false) @map("is_verified_purchase")
  createdAt           DateTime  @default(now()) @map("createdAt")
  updatedAt           DateTime  @default(now()) @updatedAt @map("updatedAt")

  // Relations
  vector              LatentVector  @relation(fields: [vectorId], references: [id])
  user                User          @relation(fields: [userId], references: [id])

  @@index([vectorId])
  @@index([userId])
  @@map("reviews")
}

model SubscriptionPlan {
  id              Int       @id @default(autoincrement())
  name            String    @db.VarChar(100)
  description     String?
  price           Decimal   @db.Decimal(10, 2)
  billingCycle    String    @map("billing_cycle") @db.VarChar(20)
  features        String?
  callLimit       Int?      @map("call_limit")
  stripePriceId   String?   @map("stripe_price_id") @db.VarChar(255)
  isActive        Boolean   @default(true) @map("is_active")
  createdAt       DateTime  @default(now()) @map("createdAt")
  updatedAt       DateTime  @default(now()) @updatedAt @map("updatedAt")

  // Relations
  subscriptions   UserSubscription[]

  @@map("subscription_plans")
}

model UserSubscription {
  id                  Int       @id @default(autoincrement())
  userId              Int       @map("user_id")
  planId              Int       @map("plan_id")
  stripeSubscriptionId String?  @map("stripe_subscription_id") @db.VarChar(255)
  status              String    @default("active") @db.VarChar(20)
  currentPeriodStart  DateTime  @map("current_period_start")
  currentPeriodEnd    DateTime  @map("current_period_end")
  cancelAtPeriodEnd   Boolean   @default(false) @map("cancel_at_period_end")
  createdAt           DateTime  @default(now()) @map("createdAt")
  updatedAt           DateTime  @default(now()) @updatedAt @map("updatedAt")

  // Relations
  user                User              @relation(fields: [userId], references: [id])
  plan                SubscriptionPlan  @relation(fields: [planId], references: [id])

  @@index([userId])
  @@index([status])
  @@map("user_subscriptions")
}

model ApiKey {
  id          Int       @id @default(autoincrement())
  userId      Int       @map("user_id")
  keyHash     String    @unique @map("key_hash") @db.VarChar(255)
  keyPrefix   String    @map("key_prefix") @db.VarChar(16)
  name        String    @db.VarChar(255)
  permissions String?
  lastUsedAt  DateTime? @map("last_used_at")
  expiresAt   DateTime? @map("expires_at")
  isActive    Boolean   @default(true) @map("is_active")
  createdAt   DateTime  @default(now()) @map("createdAt")
  updatedAt   DateTime  @default(now()) @updatedAt @map("updatedAt")

  // Relations
  user        User      @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([keyHash])
  @@map("api_keys")
}

model McpToken {
  id          Int       @id @default(autoincrement())
  userId      Int       @map("user_id")
  tokenHash   String    @unique @map("token_hash") @db.VarChar(255)
  tokenPrefix String    @map("token_prefix") @db.VarChar(16)
  name        String    @db.VarChar(255)
  permissions String?
  lastUsedAt  DateTime? @map("last_used_at")
  expiresAt   DateTime? @map("expires_at")
  isActive    Boolean   @default(true) @map("is_active")
  createdAt   DateTime  @default(now()) @map("createdAt")
  updatedAt   DateTime  @default(now()) @updatedAt @map("updatedAt")

  // Relations
  user        User      @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([tokenHash])
  @@map("mcp_tokens")
}

model ApiCallLog {
  id           Int       @id @default(autoincrement())
  userId       Int       @map("user_id")
  vectorId     Int       @map("vector_id")
  permissionId Int       @map("permission_id")
  responseTime Int?      @map("response_time")
  success      Boolean   @default(true)
  errorMessage String?   @map("error_message")
  createdAt    DateTime  @default(now()) @map("createdAt")

  // Relations
  vector       LatentVector  @relation(fields: [vectorId], references: [id])

  @@index([userId])
  @@index([vectorId])
  @@index([createdAt])
  @@map("api_call_logs")
}

model Notification {
  id              Int       @id @default(autoincrement())
  userId          Int       @map("user_id")
  type            String    @db.VarChar(50)
  title           String    @db.VarChar(255)
  message         String
  isRead          Boolean   @default(false) @map("is_read")
  relatedEntityId Int?      @map("related_entity_id")
  createdAt       DateTime  @default(now()) @map("createdAt")

  // Relations
  user            User      @relation(fields: [userId], references: [id])

  @@index([userId])
  @@index([isRead])
  @@map("notifications")
}

model UserPreference {
  id                      Int       @id @default(autoincrement())
  userId                  Int       @unique @map("user_id")
  preferredCategories     String?   @map("preferred_categories")
  priceRange              String?   @map("price_range")
  lastRecommendationUpdate DateTime? @map("last_recommendation_update")
  createdAt               DateTime  @default(now()) @map("createdAt")
  updatedAt               DateTime  @default(now()) @updatedAt @map("updatedAt")

  @@map("user_preferences")
}

model BrowsingHistory {
  id        Int       @id @default(autoincrement())
  userId    Int       @map("user_id")
  vectorId  Int       @map("vector_id")
  action    String    @db.VarChar(20)
  metadata  String?
  createdAt DateTime  @default(now()) @map("createdAt")

  @@index([userId])
  @@index([vectorId])
  @@index([createdAt])
  @@map("browsing_history")
}

model AiMemory {
  id          Int       @id @default(autoincrement())
  userId      Int       @map("user_id")
  memoryKey   String    @map("memory_key") @db.VarChar(255)
  memoryData  String    @map("memory_data")
  version     Int       @default(1)
  expiresAt   DateTime? @map("expires_at")
  createdAt   DateTime  @default(now()) @map("createdAt")
  updatedAt   DateTime  @default(now()) @updatedAt @map("updatedAt")

  @@index([userId, memoryKey])
  @@map("ai_memory")
}

// ============================================================================
// LatentMAS Package System
// ============================================================================

model VectorPackage {
  id                  Int       @id @default(autoincrement())
  packageId           String    @unique @map("package_id") @db.VarChar(64)
  userId              Int       @map("user_id")
  name                String    @db.VarChar(255)
  description         String
  vectorUrl           String    @map("vector_url")
  wMatrixUrl          String    @map("w_matrix_url")
  packageUrl          String    @map("package_url")
  sourceModel         String    @map("source_model") @db.VarChar(50)
  targetModel         String    @map("target_model") @db.VarChar(50)
  dimension           Int
  epsilon             Decimal   @db.Decimal(10, 8)
  informationRetention Decimal  @map("information_retention") @db.Decimal(5, 4)
  qualityScore        Decimal?  @default(0) @map("quality_score") @db.Decimal(5, 4)
  category            String    @default("nlp") @db.VarChar(50)
  price               Decimal   @db.Decimal(10, 2)
  downloads           Int       @default(0)
  rating              Decimal?  @default(0) @db.Decimal(3, 2)
  reviewCount         Int       @default(0) @map("review_count")
  status              String    @default("draft") @db.VarChar(20)
  createdAt           DateTime  @default(now()) @map("createdAt")
  updatedAt           DateTime  @default(now()) @updatedAt @map("updatedAt")

  @@index([userId])
  @@index([category])
  @@index([status])
  @@index([sourceModel, targetModel])
  @@map("vector_packages")
}

model MemoryPackage {
  id                  Int       @id @default(autoincrement())
  packageId           String    @unique @map("package_id") @db.VarChar(64)
  userId              Int       @map("user_id")
  name                String    @db.VarChar(255)
  description         String
  memoryType          String    @default("kv_cache") @map("memory_type") @db.VarChar(50)
  kvCacheUrl          String    @map("kv_cache_url")
  wMatrixUrl          String    @map("w_matrix_url")
  packageUrl          String    @map("package_url")
  sourceModel         String    @map("source_model") @db.VarChar(50)
  targetModel         String    @map("target_model") @db.VarChar(50)
  tokenCount          Int       @map("token_count")
  compressionRatio    Decimal   @map("compression_ratio") @db.Decimal(5, 4)
  contextDescription  String    @map("context_description")
  epsilon             Decimal   @db.Decimal(10, 8)
  informationRetention Decimal  @map("information_retention") @db.Decimal(5, 4)
  price               Decimal   @db.Decimal(10, 2)
  downloads           Int       @default(0)
  rating              Decimal?  @default(0) @db.Decimal(3, 2)
  reviewCount         Int       @default(0) @map("review_count")
  status              String    @default("draft") @db.VarChar(20)
  createdAt           DateTime  @default(now()) @map("createdAt")
  updatedAt           DateTime  @default(now()) @updatedAt @map("updatedAt")

  @@index([userId])
  @@index([status])
  @@index([sourceModel, targetModel])
  @@map("memory_packages")
}

model ChainPackage {
  id                  Int       @id @default(autoincrement())
  packageId           String    @unique @map("package_id") @db.VarChar(64)
  userId              Int       @map("user_id")
  name                String    @db.VarChar(255)
  description         String
  chainUrl            String    @map("chain_url")
  wMatrixUrl          String    @map("w_matrix_url")
  packageUrl          String    @map("package_url")
  sourceModel         String    @map("source_model") @db.VarChar(50)
  targetModel         String    @map("target_model") @db.VarChar(50)
  stepCount           Int       @map("step_count")
  problemType         String    @map("problem_type") @db.VarChar(100)
  solutionQuality     Decimal   @map("solution_quality") @db.Decimal(5, 4)
  epsilon             Decimal   @db.Decimal(10, 8)
  informationRetention Decimal  @map("information_retention") @db.Decimal(5, 4)
  price               Decimal   @db.Decimal(10, 2)
  downloads           Int       @default(0)
  rating              Decimal?  @default(0) @db.Decimal(3, 2)
  reviewCount         Int       @default(0) @map("review_count")
  status              String    @default("draft") @db.VarChar(20)
  createdAt           DateTime  @default(now()) @map("createdAt")
  updatedAt           DateTime  @default(now()) @updatedAt @map("updatedAt")

  @@index([userId])
  @@index([problemType])
  @@index([status])
  @@index([sourceModel, targetModel])
  @@map("chain_packages")
}

model PackagePurchase {
  id                    Int       @id @default(autoincrement())
  packageType           String    @map("package_type") @db.VarChar(20)
  packageId             String    @map("package_id") @db.VarChar(64)
  buyerId               Int       @map("buyer_id")
  sellerId              Int       @map("seller_id")
  price                 Decimal   @db.Decimal(10, 2)
  platformFee           Decimal   @map("platform_fee") @db.Decimal(10, 2)
  sellerEarnings        Decimal   @map("seller_earnings") @db.Decimal(10, 2)
  stripePaymentIntentId String?   @map("stripe_payment_intent_id") @db.VarChar(255)
  status                String    @default("pending") @db.VarChar(20)
  purchasedAt           DateTime  @default(now()) @map("purchasedAt")

  @@index([packageType, packageId])
  @@index([buyerId])
  @@index([sellerId])
  @@index([status])
  @@map("package_purchases")
}

// ============================================================================
// Hive Mind Memory Usage Logging
// ============================================================================

model MemoryUsageLog {
  id              Int       @id @default(autoincrement())
  consumerId      Int       @map("consumer_id")
  providerId      Int       @map("provider_id")
  memoryId        Int       @map("memory_id")
  similarity      Decimal   @db.Decimal(10, 8)
  cost            Decimal   @default(0) @db.Decimal(18, 4)
  contextQuery    String?   @map("context_query")
  createdAt       DateTime  @default(now()) @map("created_at")

  // Relations
  consumer        User      @relation("MemoryConsumer", fields: [consumerId], references: [id])
  provider        User      @relation("MemoryProvider", fields: [providerId], references: [id])

  @@index([consumerId])
  @@index([providerId])
  @@index([memoryId])
  @@index([createdAt])
  @@map("memory_usage_log")
}

// ============================================================================
// Memory NFT and Provenance
// ============================================================================

model MemoryNFT {
  id                  String    @id @db.VarChar(255)
  contractAddress     String    @map("contract_address") @db.VarChar(42)
  tokenId             String    @map("token_id") @db.VarChar(78)
  owner               String    @db.VarChar(42)
  tbaAddress          String?   @map("tba_address") @db.VarChar(42)

  // Metadata
  name                String    @db.VarChar(255)
  description         String?
  memoryType          String    @map("memory_type") @db.VarChar(50)

  // Quality metrics
  epsilon             String?   @db.VarChar(20)
  certification       String?   @db.VarChar(20)
  qualityGrade        String?   @map("quality_grade") @db.VarChar(20)

  // Asset references
  assetUrl            String?   @map("asset_url")
  metadataUrl         String?   @map("metadata_url")

  // Provenance
  parentNftId         String?   @map("parent_nft_id") @db.VarChar(255)
  derivationType      String?   @map("derivation_type") @db.VarChar(50)
  royaltyPercent      Int       @default(30) @map("royalty_percent")
  totalRoyaltiesPaid  String    @default("0") @map("total_royalties_paid") @db.VarChar(78)

  // Marketplace
  price               String?   @db.VarChar(78)
  downloads           Int       @default(0)

  // Timestamps
  mintedAt            DateTime  @default(now()) @map("minted_at")
  updatedAt           DateTime  @default(now()) @updatedAt @map("updated_at")

  @@index([contractAddress, tokenId])
  @@index([owner])
  @@index([tbaAddress])
  @@index([memoryType])
  @@index([parentNftId])
  @@map("memory_nfts")
}

// ============================================================================
// Email Verification System
// ============================================================================

model VerificationCode {
  id        Int      @id @default(autoincrement())
  userId    Int      @map("user_id")
  email     String   @db.VarChar(320)
  code      String   @db.VarChar(6)
  type      String   @default("email_verification") @db.VarChar(50)
  expiresAt DateTime @map("expires_at")
  used      Boolean  @default(false)
  createdAt DateTime @default(now()) @map("created_at")

  // Relations
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([email, code, type])
  @@index([expiresAt])
  @@index([userId])
  @@map("verification_codes")
}


// ============================================================================
// Blog System
// ============================================================================

model BlogPost {
  id          Int       @id @default(autoincrement())
  title       String    @db.VarChar(500)
  slug        String    @unique @db.VarChar(500)
  excerpt     String?
  content     String
  coverImage  String?   @map("cover_image")
  tags        String[]  @default([])
  category    String?   @db.VarChar(100)
  status      String    @default("draft") @db.VarChar(20) // draft, published, archived
  authorId    Int?      @map("author_id")
  viewCount   Int       @default(0) @map("view_count")
  publishedAt DateTime? @map("published_at")
  createdAt   DateTime  @default(now()) @map("created_at")
  updatedAt   DateTime  @updatedAt @map("updated_at")

  // Relations
  author      User?     @relation(fields: [authorId], references: [id])

  @@index([slug])
  @@index([status])
  @@index([category])
  @@index([authorId])
  @@index([publishedAt])
  @@map("blog_posts")
}

// ============================================================================
// Agent Custody Wallet (for autonomous AI stablecoin transactions)
// ============================================================================

model AgentWallet {
  id              Int       @id @default(autoincrement())
  userId          Int       @unique @map("user_id")
  walletAddress   String    @unique @map("wallet_address") @db.VarChar(42)
  encryptedKey    String    @map("encrypted_key") @db.Text
  chainId         Int       @default(137) @map("chain_id")
  dailySpendLimit Decimal   @default(500) @map("daily_spend_limit") @db.Decimal(18, 2)
  perTxSpendLimit Decimal   @default(100) @map("per_tx_spend_limit") @db.Decimal(18, 2)
  isActive        Boolean   @default(true) @map("is_active")
  createdAt       DateTime  @default(now()) @map("created_at")
  updatedAt       DateTime  @updatedAt @map("updated_at")

  // Relations
  user            User      @relation(fields: [userId], references: [id])
  transactions    AgentWalletTransaction[]

  @@index([walletAddress])
  @@map("agent_wallets")
}

model AgentWalletTransaction {
  id          Int       @id @default(autoincrement())
  userId      Int       @map("user_id")
  walletId    Int?      @map("wallet_id")
  txHash      String    @map("tx_hash") @db.VarChar(66)
  action      String    @db.VarChar(20) // deposit, purchase, withdraw, approve
  token       String    @db.VarChar(42) // token contract address
  amountUSD   Decimal   @map("amount_usd") @db.Decimal(18, 4)
  packageId   String?   @map("package_id")
  details     String?   @db.Text
  createdAt   DateTime  @default(now()) @map("created_at")

  // Relations
  user        User          @relation(fields: [userId], references: [id])
  wallet      AgentWallet?  @relation(fields: [walletId], references: [id])

  @@index([userId])
  @@index([txHash])
  @@index([createdAt])
  @@index([userId, action, createdAt])
  @@map("agent_wallet_transactions")
}

// ============================================================================
// Memory System (Phase A - Infrastructure Transformation)
// Core tables for universal AI memory management
// ============================================================================

model MemoryEntry {
  id                  String    @id @default(uuid()) @db.Uuid
  orgId               String    @map("org_id") @db.VarChar(255)
  namespace           String    @db.VarChar(255)

  // Content
  contentType         String    @map("content_type") @db.VarChar(50)
  content             String    @db.Text
  embedding           Unsupported("vector(1536)")?  // pgvector extension
  metadata            Json?

  // Quality Signals
  confidence          Decimal   @db.Decimal(3, 2) // [0.00-1.00]
  reputation          Decimal   @default(50) @db.Decimal(5, 2) // [0-100]
  usageCount          Int       @default(0) @map("usage_count")
  validationCount     Int       @default(0) @map("validation_count")

  // Conflict Detection (Phase B)
  claimKey            String?   @map("claim_key") @db.VarChar(255)
  claimValue          String?   @map("claim_value") @db.Text

  // RMC Entity Extraction (Phase C) - DEPRECATED, use EntityTag relation
  // entities            Json?     // ❌ Removed, use EntityTag table instead

  // ✅ LatentMAS Integration (Phase D)
  latentState         Unsupported("vector(1024)")?  // Hidden State from Agent's internal layers
  latentModel         String?   @map("latent_model") @db.VarChar(100) // e.g., "llama-3-8b"
  latentLayer         Int?      @map("latent_layer")  // Layer number where latent was extracted

  // NFT Metadata (for trading latent states)
  isNFTized           Boolean   @default(false) @map("is_nftized")
  nftContractAddress  String?   @map("nft_contract_address") @db.VarChar(42)
  nftTokenId          String?   @map("nft_token_id") @db.VarChar(78)
  latentValueUSD      Decimal?  @map("latent_value_usd") @db.Decimal(18, 2)

  // Versioning
  version             Int       @default(1)
  parentId            String?   @map("parent_id") @db.Uuid
  rootId              String?   @map("root_id") @db.Uuid
  isLatest            Boolean   @default(true) @map("is_latest")

  // Department & Role (Phase B - 权限隔离)
  agentId             String?   @map("agent_id") @db.VarChar(255)
  department          String?   @db.VarChar(100)
  role                String?   @db.VarChar(50)

  // Lifecycle
  createdBy           String    @map("created_by") @db.VarChar(255)
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @default(now()) @updatedAt @map("updated_at")
  accessedAt          DateTime  @default(now()) @map("accessed_at")
  expiresAt           DateTime? @map("expires_at")

  // Decay
  decayFactor         Decimal   @default(0.01) @map("decay_factor") @db.Decimal(5, 4)
  decayCheckpoint     DateTime  @default(now()) @map("decay_checkpoint")

  // Relations
  parent              MemoryEntry?      @relation("MemoryVersionTree", fields: [parentId], references: [id], onDelete: SetNull)
  children            MemoryEntry[]     @relation("MemoryVersionTree")
  score               MemoryScore?
  conflictsAsMemory1  MemoryConflict[]  @relation("ConflictMemory1")
  conflictsAsMemory2  MemoryConflict[]  @relation("ConflictMemory2")
  relationsAsSource   MemoryRelation[]  @relation("RelationSource")
  relationsAsTarget   MemoryRelation[]  @relation("RelationTarget")
  entityTags          EntityTag[]       @relation("MemoryEntityTags") // ✅ Multi-to-multi relation

  @@index([orgId, namespace])
  @@index([createdBy])
  @@index([isLatest])
  @@index([contentType])
  @@index([createdAt])
  @@index([claimKey])
  @@index([rootId])
  @@index([department])
  @@index([agentId])
  @@index([latentModel, latentLayer])
  @@index([isNFTized])
  @@map("memory_entries")
}

model MemoryScore {
  memoryId            String    @id @map("memory_id") @db.Uuid
  baseScore           Decimal   @map("base_score") @db.Decimal(5, 2)
  decayMultiplier     Decimal   @map("decay_multiplier") @db.Decimal(5, 4)
  finalScore          Decimal   @map("final_score") @db.Decimal(5, 2)
  lastCalculated      DateTime  @default(now()) @map("last_calculated")

  // Relations
  memory              MemoryEntry @relation(fields: [memoryId], references: [id], onDelete: Cascade)

  @@index([finalScore(sort: Desc)])
  @@map("memory_scores")
}

// ============================================================================
// Memory Governance (Phase B - To be implemented)
// Commented out for now, will be activated in Phase B
// ============================================================================

model MemoryPolicy {
  id                  String    @id @default(uuid()) @db.Uuid
  orgId               String    @map("org_id") @db.VarChar(255)
  namespace           String    @db.VarChar(255)
  policyType          String    @map("policy_type") @db.VarChar(50) // 'retention', 'access', 'conflict_resolution'
  rules               Json
  createdAt           DateTime  @default(now()) @map("created_at")

  @@index([orgId, namespace])
  @@map("memory_policies")
}

model MemoryAccessLog {
  id                  String    @id @default(uuid()) @db.Uuid
  memoryId            String    @map("memory_id") @db.Uuid
  accessedBy          String    @map("accessed_by") @db.VarChar(255)
  accessType          String    @map("access_type") @db.VarChar(50) // 'read', 'write', 'delete'
  accessedAt          DateTime  @default(now()) @map("accessed_at")

  @@index([memoryId])
  @@index([accessedAt])
  @@map("memory_access_logs")
}

model MemoryConflict {
  id                  String    @id @default(uuid()) @db.Uuid
  memoryId1           String    @map("memory_id_1") @db.Uuid
  memoryId2           String    @map("memory_id_2") @db.Uuid
  conflictType        String    @map("conflict_type") @db.VarChar(50) // 'claim_value_mismatch', 'semantic_contradiction'
  status              String    @default("pending") @db.VarChar(20) // 'pending', 'resolved', 'ignored'
  resolutionMemoryId  String?   @map("resolution_memory_id") @db.Uuid
  detectedAt          DateTime  @default(now()) @map("detected_at")
  resolvedAt          DateTime? @map("resolved_at")
  resolvedBy          String?   @map("resolved_by") @db.VarChar(255)

  // Relations
  memory1             MemoryEntry @relation("ConflictMemory1", fields: [memoryId1], references: [id], onDelete: Cascade)
  memory2             MemoryEntry @relation("ConflictMemory2", fields: [memoryId2], references: [id], onDelete: Cascade)

  @@index([status])
  @@index([detectedAt])
  @@index([memoryId1])
  @@index([memoryId2])
  @@map("memory_conflicts")
}

// ============================================================================
// RMC: Relational Memory Core (Phase C - Multi-AI Reasoning)
// Graph-based memory relationships for inference path discovery
// ============================================================================

model MemoryRelation {
  id                  String    @id @default(uuid()) @db.Uuid
  sourceMemoryId      String    @map("source_memory_id") @db.Uuid
  targetMemoryId      String    @map("target_memory_id") @db.Uuid

  // Relation metadata
  relationType        String    @map("relation_type") @db.VarChar(50) // CAUSES, CONTRADICTS, SUPPORTS, IMPACTS, TEMPORAL_BEFORE, etc.
  strength            Decimal   @db.Decimal(5, 4) // [0.0000-1.0000] confidence in this relation
  reason              String?   @db.Text // Optional explanation from LLM

  // Inference metadata
  inferredBy          String    @map("inferred_by") @db.VarChar(50) // 'llm', 'rule', 'manual'
  entityOverlap       Int       @default(0) @map("entity_overlap") // Number of shared entities

  // Lifecycle
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  // Relations
  sourceMemory        MemoryEntry @relation("RelationSource", fields: [sourceMemoryId], references: [id], onDelete: Cascade)
  targetMemory        MemoryEntry @relation("RelationTarget", fields: [targetMemoryId], references: [id], onDelete: Cascade)

  @@unique([sourceMemoryId, targetMemoryId, relationType])
  @@index([sourceMemoryId])
  @@index([targetMemoryId])
  @@index([relationType])
  @@index([strength(sort: Desc)])
  @@index([relationType, strength(sort: Desc)]) // ✅ Composite index for optimized queries
  @@map("memory_relations")
}

// ============================================================================
// Entity Tags (Phase D - Production Optimization)
// Replaces JSON entities field with proper relational model
// Enables reverse queries like "find all memories mentioning Elon Musk"
// ============================================================================

model EntityTag {
  id                  String    @id @default(uuid()) @db.Uuid
  name                String    @db.VarChar(255)       // "Elon Musk"
  type                String    @db.VarChar(50)        // "PERSON", "COMPANY", "TECHNOLOGY", etc.
  normalizedName      String    @map("normalized_name") @db.VarChar(255) // "elon_musk" (for deduplication)
  confidence          Decimal   @db.Decimal(3, 2)      // [0.00-1.00] Entity confidence
  mentionCount        Int       @default(0) @map("mention_count") // How many times mentioned across memories

  // Metadata
  description         String?   @db.Text               // Optional description
  aliases             String[]  @default([])           // Alternative names ["Tesla CEO", "SpaceX Founder"]

  // Lifecycle
  createdAt           DateTime  @default(now()) @map("created_at")
  updatedAt           DateTime  @updatedAt @map("updated_at")

  // Relations
  memories            MemoryEntry[] @relation("MemoryEntityTags")

  @@unique([normalizedName, type]) // Ensure entity uniqueness
  @@index([type])
  @@index([mentionCount(sort: Desc)]) // Support hot entity queries
  @@index([normalizedName])
  @@map("entity_tags")
}

// ============================================================================
// Robotics Middleware (Production-Ready)
// WebMCP + RMC + Multi-Robot Coordination
// ============================================================================

// Robot Registry
model RobotRegistry {
  robotId       String    @id @map("robot_id") @db.VarChar(255)
  name          String    @db.VarChar(255)
  type          String    @db.VarChar(50)  // quadruped, humanoid, wheeled, arm, other
  manufacturer  String    @db.VarChar(100) // unitree, boston_dynamics, other
  model         String    @db.VarChar(100)
  capabilities  Json      // ["navigation", "vision", "manipulation"]
  status        String    @db.VarChar(50)  // online, offline, busy, error
  location      Json?     // {x, y, z}
  battery       Int?      // 0-100
  lastSeen      DateTime  @map("last_seen")
  createdAt     DateTime  @default(now()) @map("created_at")

  @@index([status])
  @@index([manufacturer])
  @@index([lastSeen])
  @@map("robot_registry")
}

// Robot Sessions (WebMCP Authentication)
model RobotSession {
  id              Int       @id @default(autoincrement())
  robotId         String    @unique @map("robot_id") @db.VarChar(255)
  sessionId       String    @unique @map("session_id") @db.VarChar(255)
  userId          Int       @map("user_id")
  capabilities    Json      // {canMove, canSense, canLearn, canCollaborate}
  authenticatedAt DateTime  @map("authenticated_at")
  lastHeartbeat   DateTime  @map("last_heartbeat")

  @@index([sessionId])
  @@index([userId])
  @@map("robot_sessions")
}

// Multi-Robot Tasks
model MultiRobotTask {
  taskId      String    @id @map("task_id") @db.VarChar(255)
  name        String    @db.VarChar(255)
  description String    @db.Text
  robotIds    Json      @map("robot_ids") // ["robot1", "robot2", "robot3"]
  status      String    @db.VarChar(50)   // pending, in_progress, completed, failed
  assignments Json      // [{robotId, subtask, status, result}]
  createdAt   DateTime  @default(now()) @map("created_at")
  completedAt DateTime? @map("completed_at")

  @@index([status])
  @@index([createdAt])
  @@map("multi_robot_tasks")
}

// VR Sessions (Remote Control)
model VrSession {
  sessionId       String    @id @map("session_id") @db.VarChar(255)
  userId          Int       @map("user_id")
  robotId         String    @map("robot_id") @db.VarChar(255)
  status          String    @db.VarChar(50) // connecting, connected, disconnected
  videoStreamUrl  String?   @map("video_stream_url") @db.Text
  controlChannel  String?   @map("control_channel") @db.Text
  startedAt       DateTime  @default(now()) @map("started_at")
  endedAt         DateTime? @map("ended_at")
  metrics         Json?     // {latency, fps, bandwidth}

  @@index([userId, robotId])
  @@index([status])
  @@map("vr_sessions")
}
