# Publishing Reasoning Chains

## Overview

Publishing Reasoning Chains on the Awareness Network marketplace allows you to monetize the problem-solving processes generated by your AI models. This guide covers the complete workflow: capturing chains during model inference, formatting and preparing them for publication, meeting quality standards, setting pricing, and managing your marketplace listings.

---

## Capturing Chains During Model Inference

Reasoning Chains are captured by instrumenting the model's inference pipeline to record each step in the reasoning process. The Awareness SDK provides hooks that intercept and structure the model's chain-of-thought output.

### Automatic Capture

For models that natively produce structured chain-of-thought (e.g., models with reasoning tokens or step-by-step outputs), the SDK can automatically capture and structure the chain:

```python
from awareness_sdk import ChainCapture, ModelTarget

# Initialize the capture system
capture = ChainCapture(
    model=ModelTarget(model="claude-3.5-sonnet", endpoint="http://localhost:8080"),
    auto_detect_steps=True,          # Automatically detect reasoning steps
    capture_confidence=True,         # Estimate confidence per step
    capture_metadata=True            # Record model metadata per step
)

# Start a capture session
session = capture.start_session(
    problem_statement="Determine the optimal database sharding strategy for a 10TB dataset with mixed read/write workloads...",
    domain="software_engineering",
    tags=["databases", "sharding", "distributed-systems", "performance"]
)

# Run the model -- the chain is captured automatically
response = session.run(
    prompt="Analyze the following database workload characteristics and recommend a sharding strategy...",
    temperature=0.3,
    max_tokens=8000
)

# End the session and retrieve the captured chain
chain = session.end()

print(f"Captured {chain.num_nodes} reasoning steps")
print(f"Chain depth: {chain.max_depth}")
print(f"Branches: {chain.num_branches}")
print(f"Mean confidence: {chain.mean_confidence:.3f}")
```

### Manual Capture

For more control over chain structure, you can manually define nodes as the model generates output:

```python
from awareness_sdk import ChainBuilder

builder = ChainBuilder(
    source_model="claude-3.5-sonnet",
    domain="software_engineering"
)

# Define the problem
builder.add_node(
    type="problem_definition",
    title="Database sharding strategy selection",
    content="Given a 10TB dataset with 70% read / 30% write workload...",
    confidence=1.0
)

# Add analysis steps
node_a1 = builder.add_node(
    type="analysis",
    title="Workload characterization",
    content="The workload is read-heavy (70/30 split) with temporal patterns...",
    confidence=0.92,
    depends_on=["node_000"]
)

node_a2 = builder.add_node(
    type="analysis",
    title="Data distribution analysis",
    content="The dataset has a natural partition key (customer_id) with...",
    confidence=0.88,
    depends_on=["node_000"]
)

# Add hypotheses (creates a branch)
node_h1 = builder.add_node(
    type="hypothesis",
    title="Hash-based sharding on customer_id",
    content="Hash sharding would provide even distribution across shards...",
    confidence=0.75,
    depends_on=[node_a1, node_a2]
)

node_h2 = builder.add_node(
    type="hypothesis",
    title="Range-based sharding on timestamp",
    content="Range sharding by time would optimize temporal query patterns...",
    confidence=0.70,
    depends_on=[node_a1, node_a2]
)

# Add verification steps
node_v1 = builder.add_node(
    type="verification",
    title="Hash sharding hotspot analysis",
    content="Simulating hash distribution across 16 shards shows...",
    confidence=0.85,
    depends_on=[node_h1],
    intermediate_results={"max_shard_size": "720GB", "skew_ratio": 1.15}
)

node_v2 = builder.add_node(
    type="verification",
    title="Range sharding temporal analysis",
    content="Range partitioning by month creates uneven shards...",
    confidence=0.82,
    depends_on=[node_h2],
    intermediate_results={"max_shard_size": "1.2TB", "skew_ratio": 2.8}
)

# Synthesize and conclude
node_s = builder.add_node(
    type="synthesis",
    title="Compare sharding strategies",
    content="Hash-based sharding on customer_id provides better balance...",
    confidence=0.90,
    depends_on=[node_v1, node_v2]
)

builder.add_node(
    type="conclusion",
    title="Recommendation: Hash sharding with composite key",
    content="Recommend hash-based sharding using composite key (customer_id, region)...",
    confidence=0.88,
    depends_on=[node_s]
)

# Build the chain
chain = builder.build()
print(f"Chain built: {chain.num_nodes} nodes, {chain.num_branches} branches")
```

### Batch Capture

For capturing chains from multiple model runs (e.g., for building chain collections):

```python
from awareness_sdk import BatchChainCapture

batch = BatchChainCapture(
    model=ModelTarget(model="gpt-4", endpoint="http://localhost:8080"),
    output_dir="./captured-chains/"
)

# Define a set of problems
problems = [
    {"statement": "Problem 1...", "domain": "math", "tags": ["algebra"]},
    {"statement": "Problem 2...", "domain": "math", "tags": ["calculus"]},
    # ...
]

# Capture chains for all problems
results = batch.capture_all(
    problems=problems,
    temperature=0.3,
    max_tokens_per_problem=4000,
    parallel_workers=4
)

print(f"Captured {results.successful} chains ({results.failed} failures)")
print(f"Total nodes: {results.total_nodes}")
print(f"Mean chain depth: {results.mean_depth:.1f}")
```

---

## Formatting Requirements

Reasoning Chains must meet specific formatting requirements to be listed on the marketplace.

### Required Fields

| Field | Requirement |
|---|---|
| `problem_statement` | Clear, complete description of the problem being solved |
| `domain` | Must map to a recognized marketplace domain category |
| `tags` | At least 2 descriptive tags |
| `source_model` | Valid model identifier |
| **Per node**: `type` | Must be a valid node type |
| **Per node**: `title` | 5--200 characters |
| **Per node**: `content` | 20--5,000 characters per node |
| **Per node**: `confidence` | Float between 0.0 and 1.0 |
| **Per node**: `inputs` | Valid node IDs (except root node) |

### Structural Requirements

| Requirement | Description |
|---|---|
| **DAG structure** | Must be a valid directed acyclic graph (no cycles) |
| **Single root** | Exactly one root node (no inputs) with type `problem_definition` |
| **At least one conclusion** | Must have at least one `conclusion` node |
| **Connected graph** | All nodes must be reachable from the root |
| **Minimum depth** | At least 3 nodes from root to any conclusion |
| **Maximum nodes** | 500 nodes per chain (contact support for larger chains) |

### Validation

```python
from awareness_sdk import ChainValidator

validator = ChainValidator()

# Validate chain structure and formatting
report = validator.validate(chain)

if report.valid:
    print("Chain passes all validation checks")
else:
    print("Validation failures:")
    for error in report.errors:
        print(f"  ERROR: {error.message} (node: {error.node_id})")
    for warning in report.warnings:
        print(f"  WARNING: {warning.message}")
```

---

## Quality Standards

The Awareness Network enforces minimum quality standards for listed Reasoning Chains. Chains that fall below these thresholds are rejected from the marketplace.

### Minimum Requirements

| Metric | Minimum Threshold | Description |
|---|---|---|
| **Chain completeness** | >= 0.70 | All reasoning steps present with no logical gaps |
| **Step coherence** | >= 0.75 | Each step logically follows from its dependencies |
| **Reasoning validity** | >= 0.70 | Logical reasoning is sound and conclusions follow from premises |
| **Problem-solution alignment** | >= 0.75 | The conclusion actually addresses the stated problem |
| **Overall quality score** | >= 0.65 | Composite score (Grade D or higher) |

### Quality Assessment

The quality assessment runs automatically during the publishing process:

```python
from awareness_sdk import ChainQualityAssessor

assessor = ChainQualityAssessor()

# Run quality assessment
quality = assessor.assess(chain)

print(f"Quality Assessment Results")
print(f"{'='*50}")
print(f"Chain completeness:       {quality.completeness:.3f}  {'PASS' if quality.completeness >= 0.70 else 'FAIL'}")
print(f"Step coherence:           {quality.coherence:.3f}  {'PASS' if quality.coherence >= 0.75 else 'FAIL'}")
print(f"Reasoning validity:       {quality.validity:.3f}  {'PASS' if quality.validity >= 0.70 else 'FAIL'}")
print(f"Problem-solution align.:  {quality.alignment:.3f}  {'PASS' if quality.alignment >= 0.75 else 'FAIL'}")
print(f"Overall score:            {quality.overall:.3f}")
print(f"Grade:                    {quality.grade}")
print(f"Marketplace eligible:     {'Yes' if quality.eligible else 'No'}")
```

### Improving Quality

If your chain does not meet quality standards, the assessor provides specific recommendations:

```python
if not quality.eligible:
    print("\nImprovement recommendations:")
    for rec in quality.recommendations:
        print(f"  - {rec.category}: {rec.description}")
        if rec.affected_nodes:
            print(f"    Affected nodes: {', '.join(rec.affected_nodes)}")
```

Common improvements:

| Issue | Solution |
|---|---|
| Low completeness | Add missing intermediate steps between large logical jumps |
| Low coherence | Strengthen the logical connection between consecutive steps |
| Low validity | Review and correct logical errors or unsupported conclusions |
| Low alignment | Ensure the conclusion directly addresses the original problem |
| Low confidence | Add more verification and evidence-gathering nodes |

---

## Pricing Your Chains

### Pricing Factors

| Factor | Higher Price Justification |
|---|---|
| **Chain complexity** | More nodes, more branches, deeper reasoning |
| **Domain value** | High-value domains (medical, legal, financial, security) |
| **Novelty** | Unique problem-solving approaches or rare domains |
| **Quality grade** | Grade A chains command significant premiums |
| **Reusability** | Chains that serve as templates for many similar problems |
| **Source model** | Chains from premium models (GPT-4, Claude 3 Opus) |
| **Verification** | Independently verified chains earn trust premiums |

### Pricing Guidelines

```
┌────────────────────────────────────────────────────────────┐
│                 Reasoning Chain Pricing Guide                │
├────────────────┬──────────────┬─────────────┬──────────────┤
│ Complexity     │ Grade A      │ Grade B     │ Grade C      │
├────────────────┼──────────────┼─────────────┼──────────────┤
│ Simple         │ 50-200 AMEM  │ 25-100      │ 10-50        │
│ (3-10 nodes)   │              │             │              │
├────────────────┼──────────────┼─────────────┼──────────────┤
│ Moderate       │ 200-1,000    │ 100-500     │ 50-200       │
│ (10-30 nodes)  │              │             │              │
├────────────────┼──────────────┼─────────────┼──────────────┤
│ Complex        │ 1,000-5,000  │ 500-2,500   │ 200-1,000    │
│ (30-100 nodes) │              │             │              │
├────────────────┼──────────────┼─────────────┼──────────────┤
│ Expert         │ 5,000-50,000 │ 2,500-10,000│ 1,000-5,000  │
│ (100+ nodes)   │              │             │              │
└────────────────┴──────────────┴─────────────┴──────────────┘

Domain multipliers:
  General knowledge:     1.0x
  Software engineering:  1.2x
  Data science:          1.3x
  Financial analysis:    1.5x
  Medical reasoning:     2.0x
  Legal analysis:        1.8x
  Security research:     1.5x
```

---

## Publishing to the Marketplace

### Publication Workflow

```
┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐
│ Capture  │───>│ Validate │───>│ Quality  │───>│ Package  │───>│ Publish  │
│ chain    │    │ format   │    │ assess   │    │ & price  │    │ listing  │
└──────────┘    └──────────┘    └──────────┘    └──────────┘    └──────────┘
```

### Complete Publishing Example

```python
from awareness_sdk import (
    Marketplace, ChainValidator, ChainQualityAssessor, ChainPackager
)

market = Marketplace(api_key="your-api-key")

# Step 1: Validate
validator = ChainValidator()
validation = validator.validate(chain)
assert validation.valid, f"Validation failed: {validation.errors}"

# Step 2: Quality assessment
assessor = ChainQualityAssessor()
quality = assessor.assess(chain)
assert quality.eligible, f"Quality too low: {quality.grade}"

# Step 3: Package
packager = ChainPackager(chain)
packager.set_listing_metadata(
    name="Database Sharding Strategy Analysis",
    description="Complete reasoning chain for selecting an optimal database sharding strategy. Covers hash vs. range sharding, hotspot analysis, and composite key design for mixed read/write workloads.",
    category="software_engineering",
    tags=["databases", "sharding", "distributed-systems", "performance", "architecture"],
    preview_depth=3                  # Show first 3 nodes in preview
)

package_path = packager.save("./publish/db-sharding-analysis.awrc")

# Step 4: Publish
listing = market.chains.publish(
    package_path=package_path,
    price=500,
    currency="AMEM",
    license="marketplace-standard",
    quality_report=quality,
    allow_preview=True,
    allow_trial=False
)

print(f"Published successfully!")
print(f"  Listing ID: {listing.id}")
print(f"  URL: {listing.marketplace_url}")
print(f"  Status: {listing.status}")
print(f"  Grade: {quality.grade}")
print(f"  Price: 500 AMEM")
```

### Publishing Chain Collections

Bundle related chains into a collection for higher value:

```python
from awareness_sdk import ChainCollection

collection = ChainCollection(
    name="Complete Database Architecture Decision Patterns",
    description="50 reasoning chains covering database selection, sharding, indexing, replication, and migration decisions.",
    chains=chain_list,
    pricing="bundle"               # Bundle pricing (discount vs. individual)
)

# Publish the collection
listing = market.chain_collections.publish(
    collection=collection,
    individual_price=500,          # Price if sold individually
    bundle_price=15000,            # Price for the full collection
    currency="AMEM"
)

print(f"Collection published: {listing.marketplace_url}")
print(f"  Chains: {collection.num_chains}")
print(f"  Bundle price: 15,000 AMEM (vs. {500 * collection.num_chains:,} individually)")
```

---

## Managing Your Listings

### Listing Dashboard

```python
# View your published chains
my_listings = market.chains.my_listings()

for listing in my_listings:
    print(f"{listing.name}")
    print(f"  Status: {listing.status} | Grade: {listing.grade}")
    print(f"  Price: {listing.price} AMEM")
    print(f"  Sales: {listing.total_sales} | Revenue: {listing.total_revenue} AMEM")
    print(f"  Rating: {listing.avg_rating:.1f}/5 ({listing.num_reviews} reviews)")
```

### Updating Listings

```python
# Update price
market.chains.update(listing_id="chain_abc123", price=750)

# Update description
market.chains.update(
    listing_id="chain_abc123",
    description="Updated description with more detail..."
)

# Temporarily delist
market.chains.delist("chain_abc123")

# Relist
market.chains.relist("chain_abc123")
```

---

## Next Steps

- [Chain Structure](chain-structure.md) -- Detailed anatomy of reasoning chains
- [Evaluation Metrics](evaluation-metrics.md) -- Understanding quality scoring
- [Reasoning Chains Overview](README.md) -- Return to product overview
