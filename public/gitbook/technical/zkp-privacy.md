# ZKP Privacy System

## Zero-Knowledge Proofs for AI Knowledge Trading

The Awareness Network's Zero-Knowledge Proof (ZKP) system enables sellers to prove the quality, authenticity, and properties of their KV-Cache knowledge packages without revealing the actual contents. This preserves intellectual property while giving buyers confidence in what they are purchasing.

---

## Why Privacy Matters for AI Trading

Knowledge packages on the Awareness marketplace contain valuable intellectual property -- curated, refined representations of expertise that took significant compute and data to produce. Without privacy protections, the marketplace faces a fundamental tension:

| Problem | Description |
|---|---|
| **The Inspection Paradox** | A buyer wants to verify package quality before purchasing, but inspecting the KV-Cache reveals its contents, eliminating the need to buy. |
| **IP Theft Risk** | Preview mechanisms that expose even partial cache data allow sophisticated actors to reconstruct or approximate the full package. |
| **Competitive Intelligence** | Sellers do not want competitors to learn what domains they specialize in by analyzing their package internals. |
| **Data Sensitivity** | Some packages encode knowledge from sensitive domains (medical, legal, financial) where the training data itself may be confidential. |

Zero-Knowledge Proofs resolve this tension by allowing a seller to prove specific properties about a package (quality score, domain coverage, factual accuracy) without revealing any of the underlying tensor data.

---

## How ZKP Works in the Awareness Network

### Conceptual Overview

A Zero-Knowledge Proof allows a **prover** (the seller) to convince a **verifier** (the buyer or marketplace) that a statement is true, without revealing any information beyond the truth of that statement.

In the Awareness context:

- **Statement**: "This KV-Cache package has a quality score above 0.90, covers the domain of distributed systems, and was generated by a LLaMA 3 70B model."
- **Proof**: A cryptographic proof that the statement is true.
- **Verification**: The buyer or marketplace smart contract verifies the proof on-chain.

```
Seller (Prover)                                     Buyer (Verifier)
      │                                                   │
      │  1. Generate quality metrics from KV-Cache        │
      │     (quality_score = 0.94)                        │
      │                                                   │
      │  2. Create ZKP circuit                            │
      │     (prove quality_score > 0.90)                  │
      │                                                   │
      │  3. Generate proof ──────────────────────────────►│
      │     (proof, public_inputs)                        │
      │                                                   │
      │                            4. Verify proof ───────│
      │                               (valid: true)       │
      │                                                   │
      │                            5. Purchase with ──────│
      │                               confidence          │
      │                                                   │
```

### What Can Be Proven

| Property | Statement | Public Input | Private Input |
|---|---|---|---|
| **Quality Score** | "Quality score exceeds threshold T" | Threshold T | Actual score and raw metrics |
| **Domain Coverage** | "Package covers domain D" | Domain identifier | Domain classification vectors |
| **Model Origin** | "Generated by model M" | Model identifier hash | Model architecture details |
| **Data Freshness** | "Training data is from after date D" | Date threshold | Actual timestamps |
| **Factual Accuracy** | "Accuracy on benchmark B exceeds A%" | Benchmark ID, threshold A | Actual accuracy and test results |
| **Non-Duplication** | "Package is not a copy of package P" | Package P hash | Both packages' content hashes |
| **Size Bounds** | "Token count is between L and U" | Lower bound L, upper bound U | Actual token count |

---

## Implementation with snarkjs

The Awareness Network implements its ZKP system using [snarkjs](https://github.com/iden3/snarkjs) and [circom](https://docs.circom.io/), a mature toolkit for creating and verifying zk-SNARKs (Zero-Knowledge Succinct Non-Interactive Arguments of Knowledge).

### Circuit Architecture

```
┌─────────────────────────────────────────────────────┐
│                 ZKP Circuit Stack                     │
│                                                       │
│  ┌─────────────────────────────────────────────────┐ │
│  │  Quality Proof Circuit                           │ │
│  │  Proves: computed_score > threshold              │ │
│  │  Private: kv_cache_hash, raw_metrics             │ │
│  │  Public: threshold, model_id_hash                │ │
│  └─────────────────────────────────────────────────┘ │
│                                                       │
│  ┌─────────────────────────────────────────────────┐ │
│  │  Domain Proof Circuit                            │ │
│  │  Proves: domain_vector ∈ target_domain           │ │
│  │  Private: domain_classification_vector           │ │
│  │  Public: target_domain_id                        │ │
│  └─────────────────────────────────────────────────┘ │
│                                                       │
│  ┌─────────────────────────────────────────────────┐ │
│  │  Integrity Proof Circuit                         │ │
│  │  Proves: hash(package) == committed_hash         │ │
│  │  Private: package_contents                       │ │
│  │  Public: committed_hash                          │ │
│  └─────────────────────────────────────────────────┘ │
└─────────────────────────────────────────────────────┘
```

### Quality Proof Circuit (Circom)

```circom
pragma circom 2.1.0;

include "circomlib/comparators.circom";
include "circomlib/poseidon.circom";

template QualityProof() {
    // Private inputs (known only to the prover/seller)
    signal input qualityScore;          // Actual quality score (scaled to integer)
    signal input coherenceScore;        // Coherence sub-metric
    signal input relevanceScore;        // Relevance sub-metric
    signal input accuracyScore;         // Factual accuracy sub-metric
    signal input packageContentHash;    // Hash of the actual KV-Cache data
    signal input salt;                  // Random salt for commitment

    // Public inputs (visible to the verifier/buyer)
    signal input qualityThreshold;      // Minimum quality score required
    signal input packageCommitment;     // Poseidon hash commitment

    // Prove that the quality score exceeds the threshold
    component greaterThan = GreaterThan(32);
    greaterThan.in[0] <== qualityScore;
    greaterThan.in[1] <== qualityThreshold;
    greaterThan.out === 1;

    // Prove that the quality score is correctly computed from sub-metrics
    // quality = 0.4 * coherence + 0.35 * relevance + 0.25 * accuracy
    // (scaled by 100 to avoid floating point)
    signal computedQuality;
    computedQuality <== (40 * coherenceScore + 35 * relevanceScore + 25 * accuracyScore) / 100;

    // Allow small rounding tolerance (within 1 point)
    component diff = AbsoluteDifference();
    diff.in[0] <== qualityScore;
    diff.in[1] <== computedQuality;
    component tolerance = LessThan(32);
    tolerance.in[0] <== diff.out;
    tolerance.in[1] <== 2;
    tolerance.out === 1;

    // Prove the package commitment is valid
    component hasher = Poseidon(2);
    hasher.inputs[0] <== packageContentHash;
    hasher.inputs[1] <== salt;
    packageCommitment === hasher.out;
}

component main {public [qualityThreshold, packageCommitment]} = QualityProof();
```

### Proof Generation (TypeScript)

```typescript
import * as snarkjs from 'snarkjs';

async function generateQualityProof(
  packageMetrics: PackageMetrics,
  packageHash: bigint,
  salt: bigint,
  threshold: number
): Promise<{ proof: Proof; publicSignals: string[] }> {
  // Scale scores to integers (0-100)
  const qualityScore = Math.round(packageMetrics.overall * 100);
  const coherenceScore = Math.round(packageMetrics.coherence * 100);
  const relevanceScore = Math.round(packageMetrics.relevance * 100);
  const accuracyScore = Math.round(packageMetrics.accuracy * 100);
  const qualityThreshold = Math.round(threshold * 100);

  // Compute package commitment (Poseidon hash of content hash + salt)
  const packageCommitment = poseidonHash([packageHash, salt]);

  // Generate the proof
  const { proof, publicSignals } = await snarkjs.groth16.fullProve(
    {
      qualityScore,
      coherenceScore,
      relevanceScore,
      accuracyScore,
      packageContentHash: packageHash,
      salt,
      qualityThreshold,
      packageCommitment,
    },
    'circuits/quality_proof.wasm',
    'circuits/quality_proof_final.zkey'
  );

  return { proof, publicSignals };
}
```

### Proof Verification (TypeScript)

```typescript
async function verifyQualityProof(
  proof: Proof,
  publicSignals: string[]
): Promise<boolean> {
  const verificationKey = await snarkjs.zKey.exportVerificationKey(
    'circuits/quality_proof_final.zkey'
  );

  const isValid = await snarkjs.groth16.verify(
    verificationKey,
    publicSignals,
    proof
  );

  return isValid;
}
```

---

## Verification Flow

### End-to-End Flow

```
┌──────────┐    ┌──────────────┐    ┌────────────────┐    ┌──────────────┐
│  Seller   │    │  ZKP Service │    │   Marketplace  │    │    Buyer     │
│           │    │              │    │   Contract     │    │              │
└─────┬─────┘    └──────┬───────┘    └───────┬────────┘    └──────┬───────┘
      │                 │                    │                    │
      │  1. Submit      │                    │                    │
      │  package +      │                    │                    │
      │  metrics ──────►│                    │                    │
      │                 │                    │                    │
      │  2. Generate    │                    │                    │
      │  proof ◄────────│                    │                    │
      │                 │                    │                    │
      │  3. List with proof ────────────────►│                    │
      │                 │                    │                    │
      │                 │                    │  4. Browse ◄───────│
      │                 │                    │  listings          │
      │                 │                    │                    │
      │                 │                    │  5. Verify ◄───────│
      │                 │                    │  proof on-chain    │
      │                 │                    │                    │
      │                 │                    │  6. Purchase ◄─────│
      │                 │                    │  (if valid)        │
      │                 │                    │                    │
      │  7. Deliver package ─────────────────────────────────────►│
      │                 │                    │                    │
```

### On-Chain Verification

The verification key is deployed as a Solidity smart contract, enabling trustless on-chain proof verification:

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "./Groth16Verifier.sol";

contract AwarenessZKPVerifier {
    Groth16Verifier public qualityVerifier;
    Groth16Verifier public domainVerifier;

    mapping(bytes32 => bool) public verifiedPackages;

    event PackageVerified(
        bytes32 indexed packageCommitment,
        uint256 qualityThreshold,
        bool verified
    );

    constructor(address _qualityVerifier, address _domainVerifier) {
        qualityVerifier = Groth16Verifier(_qualityVerifier);
        domainVerifier = Groth16Verifier(_domainVerifier);
    }

    function verifyPackageQuality(
        uint256[2] calldata _pA,
        uint256[2][2] calldata _pB,
        uint256[2] calldata _pC,
        uint256[2] calldata _pubSignals  // [qualityThreshold, packageCommitment]
    ) external returns (bool) {
        bool isValid = qualityVerifier.verifyProof(_pA, _pB, _pC, _pubSignals);

        if (isValid) {
            bytes32 commitment = bytes32(_pubSignals[1]);
            verifiedPackages[commitment] = true;
            emit PackageVerified(commitment, _pubSignals[0], true);
        }

        return isValid;
    }

    function isPackageVerified(bytes32 packageCommitment) external view returns (bool) {
        return verifiedPackages[packageCommitment];
    }
}
```

---

## Performance Characteristics

| Operation | Time | Size |
|---|---|---|
| **Proof Generation** (quality circuit) | ~8 seconds | N/A |
| **Proof Generation** (domain circuit) | ~12 seconds | N/A |
| **Proof Size** | N/A | ~800 bytes |
| **Off-chain Verification** | ~10 milliseconds | N/A |
| **On-chain Verification** | ~300,000 gas (~$1.40 at 30 gwei) | N/A |
| **Trusted Setup** (one-time) | ~30 minutes | ~50 MB ceremony output |

### Trusted Setup

The zk-SNARK system requires a one-time trusted setup ceremony. The Awareness Network conducts this using a multi-party computation (MPC) ceremony where multiple independent participants contribute randomness. As long as at least one participant is honest, the setup is secure.

```bash
# Phase 1: Powers of Tau ceremony
snarkjs powersoftau new bn128 16 pot16_0000.ptau
snarkjs powersoftau contribute pot16_0000.ptau pot16_0001.ptau --name="Contributor 1"
snarkjs powersoftau contribute pot16_0001.ptau pot16_0002.ptau --name="Contributor 2"
# ... additional contributors
snarkjs powersoftau prepare phase2 pot16_final.ptau

# Phase 2: Circuit-specific setup
snarkjs groth16 setup quality_proof.r1cs pot16_final.ptau quality_proof_0000.zkey
snarkjs zkey contribute quality_proof_0000.zkey quality_proof_final.zkey --name="Contributor 1"

# Export verification key
snarkjs zkey export verificationkey quality_proof_final.zkey verification_key.json

# Export Solidity verifier
snarkjs zkey export solidityverifier quality_proof_final.zkey Groth16Verifier.sol
```

---

## Security Considerations

### Soundness

The Groth16 proof system provides computational soundness: it is computationally infeasible for a dishonest prover to generate a valid proof for a false statement. The security level is 128 bits, based on the BN254 elliptic curve.

### Zero-Knowledge Property

The proofs reveal nothing about the private inputs beyond what is implied by the public inputs. A verifier learns only that the quality score exceeds the threshold and that the package commitment is valid -- not the actual score, sub-metrics, or package contents.

### Front-Running Protection

Package commitments are published before proofs to prevent front-running attacks where a malicious actor observes a proof and copies the package before the seller's transaction is confirmed. The commitment binds the seller to the package contents without revealing them.

### Replay Protection

Each proof includes a nonce derived from the transaction context to prevent replay attacks where a valid proof is reused for a different package.
